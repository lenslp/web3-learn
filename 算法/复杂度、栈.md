## 如何计算算法时间复杂度+空间复杂度
### 时间复杂度
1. 衡量算法执行时间随着输入规模n变化的增长情况
    + O(1) 表示无论输入数据多大，执行时间都保持不变
    + O(n) 表示执行时间与输入数据的大小成正比
    + O(n^2) 表示执行时间与输入数据的大小成平方关系
    + O(log n) 表示执行时间与输入规模n的对数成正比
    + O(n log n) 表示执行时间与n乘以log n成正比
2. 如何计算：
    + 基本操作：O(1)，比如x = 5
    + 单层循环：若循环从1迭代到n，则时间复杂度是 O(n)
    + 嵌套循环：O(n²)，一个循环内有另一个循环
    + 递归分析：找递归关系式，比如：T(n) = T(n-1) + T(n-2) + 1 → 时间复杂度：O(2ⁿ)
### 空间复杂度
1. 衡量算法在执行过程中使用的内存的大小，通常与输入规模n的大小有关
    + O(1) 表示所需的空间是固定的，不依赖于输入规模
    + O(n) 表示空间使用与输入规模n成正比
    + O(n²) 表示空间使用与输入规模n的平方成正比
2. 如何计算：
    + 变量：O(1)
    + 大小为n的数组或数据结构：O(n)
    + 递归算法的空间复杂度还需要考虑递归调用栈的使用。例如，递归深度为n的算法，其空间复杂度通常是 O(n)
    + 多个数据结构的空间复杂度需要相加：比如，如果使用了一个大小为n的数组和一个大小为m的链表，空间复杂度就是 O(n + m)
    + 忽略常数项和低阶项：例如，如果空间需求是 O(3n + 5)，则简化为 O(n)
## 什么是栈？JavaScript中有哪些栈的具体应用？
1. 遵循先进后出的原则，栈中元素的插入和移除操作都发生在栈顶
    + push：将元素压入栈顶
    + pop: 从栈顶移除元素
2. 应用：
    + 函数调用栈：函数调用遵循栈的顺序。当一个函数被调用时，它会被压入调用栈中。当函数执行完毕，它会被从栈中弹出。栈确保了函数执行的顺序
    + 浏览器历史记录管理

## 利用栈进行二叉树前序遍历
1. 前序遍历的核心规则是：根节点 → 左子树 → 右子树
2. 栈实现：时间、空间复杂度都是O (n)
    + 栈的初始化：将根节点直接入栈，保证首次处理根节点
    + 循环条件：栈不为空（stack.length > 0）时持续处理
    + 节点弹出与访问：每次弹出栈顶节点，将值存入结果数组
    + 子节点入栈顺序：先右后左（栈是后进先出）
    + 边界场景处理：如果输入的二叉树为空（root = null），函数直接返回空数组
```typescript
// 1. 定义二叉树节点类
class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function preorderTraversal(root) {
  // 边界处理：空树直接返回空数组
  if (!root) return [];

  const result = []; // 存储遍历结果
  const stack = [root]; // 初始化栈，根节点入栈

  // 循环处理栈内节点
  while (stack.length > 0) {
    // 弹出栈顶节点并访问（存入结果）
    const node = stack.pop();
    result.push(node.value);

    // 关键：先入栈右子节点（后进先出，保证左子树先处理）
    if (node.right) stack.push(node.right);
    // 后入栈左子节点
    if (node.left) stack.push(node.left);
  }

  return result;
}
```
3. 递归实现：
```typescript
function preorderTraversal(root) {
    if(!root) return []
    const result = [root.value]
    result.push(...preorderTraversal(root.left))
    result.push(...preorderTraversal(root.right))
    return result;
}
```

## 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
+ 左括号必须用相同类型的右括号闭合。
+ 左括号必须以正确的顺序闭合。
+ 每个右括号都有一个对应的相同类型的左括号。
```typescript
function isValid(str){
    const map = {
        '(': ')',
        '{': '}',
        '[': ']',
    }
    const stack = []
    for (let char of str) {
        // 如果是左括号，压入栈
        if (map[char]) {
            stack.push(char);
        } else {
            // 如果是右括号，检查栈顶是否有对应的左括号
            const top = stack.pop();
            if (map[top] !== char) {
                return false;
            }
        }
    }
    return stack.length === 0;
}
isValid('())') // false
isValid('(){}') // true
```