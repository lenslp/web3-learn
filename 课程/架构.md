# 技术选型

## 前端框架选型
1. css: [state css](https://stateofcss.com/en-US) 查看全球css库使用情况
    + twailwindcss：原子化，节省体积
2. js框架排名：https://bestofjs.org/ 
3. js框架排名：https://risingstars.js.org/2024/en

## css发展史
1. 传统css
2. 预处理器：sass、less
3. cssnext雏形
4. css modules
5. css in js
6. 回归纯css：tailwindcss

## 包管理工具怎么选
1. npm：
    + 优点：node官方包管理器、生态完善
    + 缺点：扁平化依赖，会把子依赖也提升到顶层，导致出现幽灵依赖，容易“本地能跑，线上炸”
2. yarn（Classic版）：
    + 优点：解决了npm幽灵依赖问题、支持并行下载安装速度快
    + 缺点：软链，不节省磁盘空间
3. yarn（Berry版）
    + 和pnpm类似，采用硬链
    + 兼容性差
3. pnpm
    + 优点：强制依赖隔离，避免幽灵依赖；节省磁盘空间、安装速度快、支持 monorepo
    + 缺点：早期兼容性差，部分老项目不能用、云平台不支持
    + 软链（目录）+ 硬链（文件）混合：.pnpm 是 pnpm 存放“真实依赖内容”的地方，
外层 node_modules 只是“引用入口”，不是实际代码，真实文件存放在.pnpm-store中，全局共享
```typescript
node_modules/react
  └─(软链接 symlink)
    → node_modules/.pnpm/react@18.2.0/node_modules/react
        └─ index.js  (硬链接 hard link)
            ↔ ~/.pnpm-store/.../react/index.js
```
4. 硬链和软链的区别
    + 硬链：与原文件共享相同的inode，删除原文件后，硬链仍然有效，仍可访问文件内容
    + 软链：类似快捷方式，指向原始文件，原文件删除后链接失效
5. pnpm 为什么快？
    + 全局缓存：包只下载一次，项目间复用缓存
    + node_modules 不复制代码：使用硬链和软链，避免重复复制文件
5. pnpm早期部署aws、cloudflare、serverless等云平台时会出现问题
    + 硬链接 + 非扁平 node_modules 与平台构建机制不兼容
    + 这些问题在今天已经基本解决

## PWA
1. PWA（Progressive Web App，渐进式网页应用）是一种利用现代网页技术实现类似原生应用体验的网页应用。
2. PWA 的核心技术包括：
    + Service Workers：在后台运行的脚本，负责缓存资源、处理离线请求、推送通知等功能。
    + Web App Manifest：一个 JSON 文件，定义应用的元数据，如名称、图标、启动 URL 等。
    + Service Worker 必须在 HTTPS 下
3. PWA 的优势：离线访问、
    + 离线访问：通过缓存机制，用户可以在没有网络连接时访问应用。
    + 安装方便：用户可以将 PWA 添加到主屏幕，类似于原生应用。
    + 自动更新：PWA 可以自动更新，无需用户手动下载新版本。
    + 跨平台兼容：PWA 可以在各种操作系统和设备上运行，无需针对不同平台开发多个版本。

## AMP
1. Google 推的“极致快的移动页面规范”，通过限制 HTML、CSS 和 JavaScript 的使用，优化页面加载速度和性能。
2. 主要限制：
    + 禁止使用自定义 JavaScript，只允许使用 AMP 提供的组件。
    + 限制 CSS 的大小和复杂度，要求内联样式且不超过 50KB。
    + 使用异步加载资源，避免阻塞渲染。

## 去虚拟dom
现在很多框架“去虚拟 DOM”，不是因为虚拟 DOM 不好，而是因为它已经不再是性能最优解。
1. 常见误解：虚拟 DOM 快，是因为减少了 DOM 操作，但实际上，虚拟 DOM 需要进行 diff，复杂页面中diff 成本已经超过 DOM 更新成本。
2. 现代浏览器优化：现代浏览器对 DOM 操作进行了大量优化，直接操作 DOM 的性能已经大幅提升。
3. 现代框架开始思考：能不能把这些工作挪到「编译期」完成，而不是运行时完成，从而进一步提升性能。代表框架： Svelte、Solid、Qwik 等。
4. 为什么react仍然采用虚拟dom：React 的目标已经不是，而是并发渲染、可中断、可恢复、跨平台一致性，虚拟 DOM 非常适合调度和中断。

## rust、go、assembly

## React developer tools
+ 快速定位组件所对应的真实dom
+ 挂起组件模拟组件加载缓慢场景
使用中再补充...

## 打包工具
1. [webpack.md](webpack.md)
2. bun
    + 是一个现代化的 JavaScript 运行时，集成了打包、转译、测试等功能，内置了高性能的代码质量工具，旨在简化前端开发流程。

## 单元测试
[单元测试.md](单元测试.md)

## UI框架
1. mui
    + 完整、成熟、开箱即用的企业级 UI 框架
    + 快速搭建应用，不适合深度定制
2. shadcn/ui
    + 给你“源码级控制权”的组件集合
    + 基于 Tailwind CSS 和 Radix UI 构建
    + 适合需要高度定制化的项目

## hooks
1. useImmer
    + 在 React 中，state 应该被当作不可变数据，不能直接修改 state 里的字段；直接改对象或数组里的属性，React 既不一定能检测到变化，还会污染之前渲染用的那份状态快照，所以需要先基于旧状态拷贝出一个新对象，再修改后交给 setState。
    + Immer 通过 Proxy 创建一个“草稿状态”（draft），你在 draft 上可以用“可变写法”随意修改字段，底层会记录这些变更，并基于旧状态生成一个全新的不可变新状态对象；因此看起来是直接改状态，实际上原状态始终不变，只是自动帮你生成了新状态
    + 函数签名
    + 延伸面试题：
        - ts如何动态设置类型：范型
        - 怎么避免react意外渲染：immer
        - hooks怎么写
        - 你怎么看待用过的状态管理库：immmer、redux、mobx、recoil、zustand
        - 自己写过hooks吗

## lint
1. biome
    + 用 Rust 写的 前端代码工具链，主打“格式化 + Lint 一体化”，可以理解成「Prettier + ESLint 的高速合体版」，专门服务于 JS/TS 等 Web 项目。
    + 配置简单，性能优异，开箱即用
    + 生态不如 ESLint 丰富，但对于大部分项目已经足够用

## ts
1. tsconfig.json 配置详解

## wdyr（Why Did You Render）
1. 是什么：React 性能调试工具，用来帮你找出：组件为什么会重新渲染（render）
2. 应用场景
    + 性能优化：识别不必要的渲染，帮助开发者优化组件性能。
    + 调试工具：在开发过程中，实时监控组件渲染行为，快速定位性能瓶颈。
3. nextjs 中使用
    + wdyr 只用于 Client Components，不能用于 Server Components
    + 只在开发环境使用，生产环境禁用
```typescript
if (process.env.NODE_ENV === "development") {
  const whyDidYouRender = require("@welldone-software/why-did-you-render");
  whyDidYouRender(React, {
    trackAllPureComponents: true,
  });
}
``` 