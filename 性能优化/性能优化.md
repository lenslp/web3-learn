## 步骤
1. 分析性能问题
2. 给出解决方案
3. 实施方案
3. 建立完整的指标体系，持续监控
4. 持续优化

## 当前存在什么性能问题
+ k线图加载时间过长，导致用户等待时间过长
+ 交易对列表每次切换都需要重新请求数据
+ 高并发模式下ssr模式渲失败问题

## 性能指标
### web-vitals性能指标
通过web-vitals库收集性能指标
+ FP：页面首次绘制的时间，通常要求≤1s
+ FCP：页面首次内容渲染完成的时间，通常要求≤1.8s
+ LCP：页面中最大的内容元素渲染完成的时间，通常要求≤2.5s
+ FPS：页面在 1 秒内渲染的帧数，通常要求≥60fps。
+ FID：首次交互延迟，用户首次交互到页面响应的时间，通常要求≤100ms。
+ INP：交互延迟，用户交互到下一次页面重绘的时间，通常要求≤200ms。
+ CLS：累计布局偏移，衡量页面在加载过程中，元素位置变化的程度，通常要求≤0.1。
+ TTFB：从用户发起请求到服务器响应第一个字节的时间，通常要求≤0.8s。
+ 自定义指标：根据业务场景，制定自定义的性能指标，例如：订单处理时间、k线图加载时间
### 其他性能指标
通过performanceObserver、performance.getEntriesByType监听性能指标（performance.timing已废弃）
+ getEntriesByType 是同步获取已记录的性能数据，PerformanceObserver是异步监听性能事件，更适合监控动态变化或稍后发生的事件
+ 长任务监控：entry.duration > 50 // 超过50ms的任务为长任务
+ 资源加载时间: img、script、style等资源的加载时间和大小
+ 导航时间：dns解析时间、tcp连接时间、response时间、dom解析时间
```
// 收集FCP、LCP
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry);
  }
});
observer.observe({ type: 'paint' });
```
+ web-vitals相比于performanceObserver的优势：
    + 聚焦核心指标。
    + 更准确：指标计算涉及边缘情况（如 LCP 元素动态变化、CLS 跨 iframe 计算），web-vitals 已内置处理逻辑，无需开发者手动实现。
    + 一行代码即可监听指标，自动兼容不同浏览器。
### 自定义指标
+ 交易提交时间：用户点击下单按钮到订单成交的时间
+ k线图加载时间
### 错误监控
+ js错误：window.addEventListener('error', (event) => {});
+ promise错误：window.addEventListener('unhandledrejection', (event) => { console.error(event.reason) });
+ 资源加载错误：window.addEventListener('error', (event) => { event.target.src });

## 性能监控与分析搭建
1. 性能监控sdk开发：指标收集、上报
2. 数据库表设计：ORM采用prisma
    + 项目表：存储项目相关信息，包括项目名称、项目ID等。
    + 性能指标表：存储性能指标数据，包括长任务、资源加载时间、导航时间、绘制时间等。
    + 错误日志表：存储错误日志数据，包括js错误、promise错误、资源加载错误等。
3. 性能分析平台搭建：
    + 基于Next.js搭建前端应用
    + 数据库采用postgresql，prisma作为ORM进行数据操作
    + 提供性能指标可视化展示，包括：
        + 图表：展示性能指标的趋势和分布，例如折线图、柱状图等。
        + 表格：展示详细的性能指标数据，例如每个页面的加载时间、资源加载时间等。
        + 错误日志：展示错误日志数据，包括错误类型、错误信息、发生时间等。
    + 实现错误日志的搜索、过滤、分析功能

## 性能优化方向：
### 资源加载优化：压缩、缓存、懒加载、预加载、按需加载
+ 静态资源（css、js、图片等）使用service worker缓存，减少重复请求。
    - 使用 next-pwa 自动将静态资源缓存到service worker中，实现离线访问。
+ next/image：next/image默认支持图片压缩、缓存、懒加载、格式转换、预加载（priority属性）等优化。
+ next/script：通过 strategy 参数控制脚本加载时机
    - lazyOnload：非关键脚本延迟加载，避免阻塞首屏渲染。
    - beforeInteractive：关键脚本（如全局状态初始化脚本）在页面交互前加载。
    - onLoad：在页面加载完成后立即执行脚本，比如：监控。
+ next/dynamic，将非首屏渲染的资源（成交记录、当前委托）按需加载，减少主包js体积。
+ next/link默认在视口内预加载链接对应的页面资源，用户点击时可瞬间跳转。非关键链接（如外部链接）可通过 prefetch={false} 禁用预加载。
+ 静态资源通过Cloudflare CDN分发，减少服务器负载，提高响应速度。
    - 将域名的 DNS 解析指向 Cloudflare
+ 开启http2/3协议，支持多路复用、压缩等优化，减少请求延迟。
+ 开启brotli压缩，进一步压缩静态资源，减少传输大小。(相比gzip压缩，压缩率更高，传输速度更快)
### 渲染优化
+ 头部行情信息：通过服务端渲染（SSR），将实时行情数据直接嵌入到HTML中，避免客户端请求数据导致的延迟渲染问题。
    - 对 fetch 显式设置 cache: 'no-store'（禁用缓存），或者在路由配置中设置 export const dynamic = 'force-dynamic'（整个路由禁用缓存）
+ 项目中合理利用 React.memo、useMemo、useCallback保持稳定的引用，避免不必要的渲染
+ 使用suspense包裹k线图、订单薄等加载比较慢的组件，实现流式渲染，避免阻塞其他组件的渲染。
### 运行时优化
+ 避免在客户端组件中进行复杂计算，将耗时逻辑（K 线指标计算）在 Web Worker 中执行。
+ 高频操作：如价格输入、订单提交等，通过防抖、节流等技术，减少对服务器的请求次数，提高响应速度。
+ 行情数据通过 RXJS 的 distinctUntilChanged 过滤重复数据，避免不必要的渲染。
+ 订单薄、成交记录等高频更新的列表，使用 requestAnimationFrame 批量处理 DOM 操作，减少重排次数。
+ 在面对 WebSocket 毫秒级高频推送（如交易所订单簿、实时行情）时，前端需通过数据处理优化、渲染策略调整和主线程保护三大层面，平衡实时性与渲染性能，避免页面卡顿或崩溃。
    - 只处理变化的数据：服务端推送增量更新，而非全量数据，前端维护一份内存中的数据快照，仅对变化字段进行局部更新，避免全局替换。
    - 服务端传输二进制数据，并且启用gzip压缩，前端接收二进制数据，避免 JSON 解析带来的性能损耗。
    - 通过节流限制更新频率，每秒更新10次，避免高频推送导致的性能问题。也可以根据用户设备性能（navigator.hardwareConcurrency），动态调整更新频率。
    - dom复用：创建固定10个dom元素，更新时仅修改内容，避免删除重建。对价格变动的行，用 CSS 类名切换（如涨跌颜色），避免 inline-style 导致的重绘
    - 订单簿排序、二进制解析放在web worker中，避免阻塞主线程。
    - 将渲染操作放入 requestAnimationFrame，确保与浏览器刷新频率（通常 60fps，约 16ms / 帧）对齐，避免在帧中间渲染导致的画面撕裂。

数据层：增量更新、二进制解析、节流，减少计算量；
渲染层：DOM 复用、合成层隔离、虚拟列表，降低重排重绘；
线程层：Web Worker 分流计算、优先级队列保障核心交互。

## cloudflare的优势
+ 全球CDN网络：覆盖200多个国家和地区，提供低延迟的内容分发。
+ 智能缓存：根据内容类型和访问模式智能缓存静态资源，减少服务器负载。
+ 动态请求优化：即使是 API 等动态请求（无法缓存的内容），也能通过 智能路由 选择最优链路（避开拥堵节点），并压缩传输数据（Brotli/Gzip），减少传输时间。

## 基于web vitals指标的优化方案
交易页分为 “行情区（K 线 + 深度图）、交易区（币对选择 + 下单表单）、订单区（当前订单 + 历史订单）” 三大模块，需针对性优化：
1. FCP、LCP：
    + 导航栏中的固定入口，如行情、交易、合约、理财、平台logo等，通过 SSG 在构建阶段直接生成 HTML，客户端只需加载样式即可渲染，核心样式会内联到 HTML 中，避免外部css加载延迟导致的闪烁，确保html加载完毕后立即呈现正确样式
    + 导航栏中的用户头像、充值、资产、订单等低频变动内容，通过 SSR 在服务端请求用户会话数据后，直接嵌入导航栏 HTML 中
    + 服务端调用行情api，获取目标交易对的实时数据，将数据以全局变量形式嵌入到返回的html中，客户端从全局变量读取数据进行渲染（服务端帮客户端提前完成数据请求，客户端负责渲染），当客户端接收到websocket实时推送的数据时，立即替换初始数据并更新dom。
    + 通过React.memo封装行情展示组件，仅当相关数据更新时才触发渲染
    + 通过Dynamic功能，将交易页中的非首屏模块：比如交易数据、币种信息等进行按需加载，减少首屏体积。
    + 静态资源（js、css、图片）cdn加速、通过cache-control：max-age=31536000，设置长期缓存，避免重复请求。
    + k线图、订单簿使用suspense组件包裹，实现流式渲染，避免阻塞首屏渲染
3. FPS：优化渲染性能，避免页面卡顿。
    + 订单薄：采用react-window的FixedSizeList组件，仅渲染当前可见区域的订单，避免渲染所有订单导致的性能问题
    + k线图：
        + 控制k线数据更新频率，通过 RXJS 的debounceTime(10)或throttleTime(16)控制 K 线更新频率，确保每秒更新不超过 60 次，避免过于频繁的渲染导致的性能问题。
        + 增量更新避免全量渲染：仅更新新增或者变化的k线数据，避免每次数据更新都触发全量渲染，提高渲染效率。
        + 将复杂技术指标的计算逻辑迁移到web worker线程，避免阻塞主线程渲染。
    + 交易对：
        + next/image图片压缩与懒加载
4. INP：优化交互响应时间，确保用户操作及时反馈。
    + 用MobX的action.bound批量处理表单状态更新，输入数量后，仅触发 “金额计算” 相关状态更新，避免表单整体重渲染，交互响应时间从 150ms 降至 70ms。
    + 币对选择下拉框：采用 “虚拟滚动 + 搜索防抖”，基于react-window实现可视区渲染（仅显示 10 个选项），搜索输入用RXJS的debounceTime(200ms)，避免高频请求，搜索响应时间降低到250ms左右
6. CLS：优化布局偏移，确保页面元素位置稳定。
    + 订单薄：固定价格、数量、合集列的宽度，避免订单信息更新时导致的布局偏移
    + k线图：固定宽度、高度，避免数据更新时导致的布局偏移


## 常用性能优化API
1. IntersectionObserver → 懒加载
    + 用于监听元素是否进入视口，实现按需加载，避免首屏加载时加载所有资源。
2. requestIdleCallback → 空闲任务
    + 用于在浏览器空闲时执行任务，避免阻塞主线程渲染。
3. requestAnimationFrame → 流畅动画
    + 用于在浏览器下一个动画帧渲染前执行任务，确保动画流畅。
4. ResizeObserver → 尺寸监听
    + 用于监听元素尺寸变化，避免频繁触发重绘。
5. performance.now() → 性能测量
    + 高精度时间戳，用于测量代码执行时间，帮助定位性能问题。
6. preload/prefetch → 资源预加载
    + 用于提前加载资源，避免用户点击时再加载，提升用户体验。
    + preload: 预加载当前页面 立即需要 的关键资源
    + prefetch: 预加载用户 未来可能访问 的资源（非当前页面急需）
    + 借助guess.js实现预加载，根据用户行为预测用户可能点击的链接，提前加载资源，提升用户体验。
7. Cache API → 离线缓存
    + 用于缓存资源，避免重复请求，提升加载速度。
8. Web Workers → 后台计算
    + 用于在后台线程执行计算任务，避免阻塞主线程渲染，提升页面响应速度。
9. visibilityState → 节流优化
    + 用于监听页面可见性变化，避免在页面不可见时执行任务，提升性能。
