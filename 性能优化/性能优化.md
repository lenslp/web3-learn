## 步骤
1. 分析性能问题：采集性能数据上报监控平台
2. 给出解决方案：针对异常指标，给出解决方案
3. 实施方案：业务团队实施方案
4. 建立完整的指标、监控、优化闭环，持续优化

## 当前存在什么性能问题
+ k线图加载时间过长，导致用户等待时间过长
+ 交易对列表每次切换都需要重新请求数据
+ 高并发模式下ssr模式渲失败问题

## 对标竞品
1. 通过Playwright（升级版puppeteer） + PageSpeed写脚本自动刷新采集竟品指标数据，固定变量（浏览器、网络环境、设备），上报到监控平台
    + Playwright：启动一个无头浏览器，模拟用户行为
    + PageSpeed：调用 Lighthouse 获取标准性能评分
2. 采集本公司自己的数据，进行对比分析

## 性能指标
### web-vitals性能指标
通过web-vitals库收集性能指标
+ FP：页面首次绘制的时间，通常要求≤1s
+ FCP：页面首次内容渲染完成的时间，通常要求≤1.8s
+ LCP：页面中最大的内容元素渲染完成的时间，通常要求≤2.5s
+ FPS：页面在 1 秒内渲染的帧数，通常要求≥60fps。
+ FID：首次交互延迟，用户首次交互到页面响应的时间，通常要求≤100ms。
+ INP：交互延迟，用户交互到下一次页面重绘的时间，通常要求≤200ms。
+ CLS：累计布局偏移，衡量页面在加载过程中，元素位置变化的程度，通常要求≤0.1。
+ TTFB：从用户发起请求到服务器响应第一个字节的时间，通常要求≤0.8s。
+ 自定义指标：根据业务场景，制定自定义的性能指标，例如：订单处理时间、k线图加载时间

### 其他性能指标
通过performanceObserver、performance.getEntriesByType监听性能指标（performance.timing已废弃）
+ getEntriesByType 是同步获取已记录的性能数据，PerformanceObserver是异步监听性能事件，更适合监控动态变化或稍后发生的事件
+ 长任务监控：entry.duration > 50 // 超过50ms的任务为长任务
+ 资源加载时间: img、script、style等资源的加载时间和大小
+ 导航时间：dns解析时间、tcp连接时间、response时间、dom解析时间
```
// 收集FCP、LCP
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry);
  }
});
observer.observe({ type: 'paint' });
```
+ 接口请求时间
```typescript
performance.getEntriesByType('resource')
```
+ web-vitals相比于performanceObserver的优势：
    + 聚焦核心指标。
    + 更准确：指标计算涉及边缘情况（如 LCP 元素动态变化、CLS 跨 iframe 计算），web-vitals 已内置处理逻辑，无需开发者手动实现。
    + 一行代码即可监听指标，自动兼容不同浏览器。
### 自定义指标
+ 交易提交时间：用户点击下单按钮到订单成交的时间
+ k线图加载时间
### 错误监控
+ js错误：window.addEventListener('error', (event) => {});
+ promise错误：window.addEventListener('unhandledrejection', (event) => { console.error(event.reason) });
+ 资源加载错误：window.addEventListener('error', (event) => { event.target.src });

## 性能监控与分析搭建
1. 性能监控sdk开发：指标收集、上报
2. 数据库表设计：ORM采用prisma
    + 项目表：存储项目相关信息，包括项目名称、项目ID等。
    + 性能指标表：存储性能指标数据，包括长任务、资源加载时间、导航时间、绘制时间等。
    + 错误日志表：存储错误日志数据，包括js错误、promise错误、资源加载错误等。
    + 竟品数据表
3. 性能分析平台搭建：
    + 接入三方的，统计实际用户体验
    + 自研的：统计和竞品的差距的
        + 基于Next.js搭建前端应用
        + 数据库采用postgresql，prisma作为ORM进行数据操作（相比mysql更轻量）
        + 提供性能指标可视化展示，包括：
            + 图表：展示性能指标的趋势和分布，例如折线图、柱状图等。
            + 表格：展示详细的性能指标数据，例如每个页面的加载时间、资源加载时间等。
            + 错误日志：展示错误日志数据，包括错误类型、错误信息、发生时间等。
        + 实现错误日志的搜索、过滤、分析功能

## 性能优化方向：
### 资源加载优化：压缩、缓存、懒加载、预加载、按需加载
1. 静态资源（css、js、图片等）使用service worker缓存，减少重复请求。
    - 使用 next-pwa 自动将静态资源缓存到service worker中，实现离线访问。
2. next/image：next/image默认支持图片压缩、缓存、懒加载、格式转换、预加载（priority属性）等优化。
3. next/script：通过 strategy 参数控制脚本加载时机
    - lazyOnload：非关键脚本延迟加载，避免阻塞首屏渲染。
    - beforeInteractive：关键脚本（如全局状态初始化脚本）在页面交互前加载。
    - onLoad：在页面加载完成后立即执行脚本，比如：监控。
4. next/dynamic，将非首屏渲染的资源（成交记录、当前委托）按需加载，减少主包js体积。
5. next/link默认在视口内预加载链接对应的页面资源，用户点击时可瞬间跳转。非关键链接（如外部链接）可通过 prefetch={false} 禁用预加载。
6. 静态资源通过CDN分发，减少服务器负载，提高响应速度。
7. 开启http3协议，支持多路复用、压缩等优化，减少请求延迟。
8. 开启brotli压缩，进一步压缩静态资源，减少传输大小。(相比gzip压缩，压缩率更高，传输速度更快)
### 渲染优化
+ 头部行情信息：服务端渲染（SSR），将实时行情数据直接嵌入到HTML中，避免客户端请求数据导致的延迟渲染问题。
+ 项目中合理利用 React.memo、useMemo、useCallback保持稳定的引用，避免不必要的渲染
+ 流式渲染：使用suspense包裹k线图、订单薄等加载比较慢的组件，实现流式渲染，避免阻塞其他组件的渲染。
### 运行时优化
+ 避免在客户端组件中进行复杂计算，将耗时逻辑（K 线指标计算）在 Web Worker 中执行。
+ 高频操作：如价格输入、订单提交等，通过防抖、节流等技术，减少对服务器的请求次数，提高响应速度。
+ 行情数据通过 RXJS 的 distinctUntilChanged 过滤重复数据，避免不必要的渲染。
+ 订单薄、成交记录等高频更新的列表，使用 requestAnimationFrame 批量处理 DOM 操作，减少重排次数。
+ 在面对 WebSocket 毫秒级高频推送（如交易所订单簿、实时行情）时，通过节流减少数据更新频率。
    - 只处理变化的数据：服务端推送增量更新，而非全量数据，前端维护一份内存中的数据快照，仅对变化字段进行局部更新，避免全局替换。
    - 服务端传输二进制数据，并且启用gzip压缩，前端接收二进制数据，避免 JSON 解析带来的性能损耗。
    - 通过节流限制更新频率，每秒更新10次，避免高频推送导致的性能问题。也可以根据用户设备性能（navigator.hardwareConcurrency），动态调整更新频率。
    - 订单簿排序、二进制解析放在web worker中，避免阻塞主线程。
    - 将渲染操作放入 requestAnimationFrame，确保与浏览器刷新频率（通常 60fps，约 16ms / 帧）对齐，避免在帧中间渲染导致的画面撕裂。

## cloudflare的优势
+ 全球CDN网络：覆盖200多个国家和地区，提供低延迟的内容分发。
+ 智能缓存：根据内容类型和访问模式智能缓存静态资源，减少服务器负载。
+ 动态请求优化：即使是 API 等动态请求（无法缓存的内容），也能通过 智能路由 选择最优链路（避开拥堵节点），并压缩传输数据（Brotli/Gzip），减少传输时间。

## 基于web vitals指标的优化方案
交易页分为 “行情区（K 线 + 深度图）、交易区（币对选择 + 下单表单）、订单区（当前订单 + 历史订单）” 三大模块，需针对性优化：
1. FCP、LCP：
    + 导航栏中的固定入口，如行情、交易、合约、理财、平台logo等，通过 SSG 在构建阶段直接生成 HTML，客户端只需加载样式即可渲染，核心样式会内联到 HTML 中，避免外部css加载延迟导致的闪烁，确保html加载完毕后立即呈现正确样式
    + 导航栏中的用户头像、充值、资产、订单等低频变动内容，通过 SSR 在服务端请求用户会话数据后，直接嵌入导航栏 HTML 中
    + 服务端调用行情api，获取目标交易对的实时数据，将数据以全局变量形式嵌入到返回的html中，客户端从全局变量读取数据进行渲染（服务端帮客户端提前完成数据请求，客户端负责渲染），当客户端接收到websocket实时推送的数据时，立即替换初始数据并更新dom。
    + 通过React.memo封装行情展示组件，仅当相关数据更新时才触发渲染
    + 通过Dynamic功能，将交易页中的非首屏模块：比如交易数据、币种信息等进行按需加载，减少首屏体积。
    + 静态资源（js、css、图片）cdn加速、通过cache-control：max-age=31536000，设置长期缓存，避免重复请求。
    + k线图、订单簿使用suspense组件包裹，实现流式渲染，避免阻塞首屏渲染
3. FPS：优化渲染性能，避免页面卡顿。
    + k线图：
        + 控制k线数据更新频率，通过 RXJS 的debounceTime(10)或throttleTime(16)控制 K 线更新频率，确保每秒更新不超过 60 次，避免过于频繁的渲染导致的性能问题。
        + 增量更新避免全量渲染：仅更新新增或者变化的k线数据，避免每次数据更新都触发全量渲染，提高渲染效率。
        + 将复杂技术指标的计算逻辑迁移到web worker线程，避免阻塞主线程渲染。
4. INP：优化交互响应时间，确保用户操作及时反馈。
    + 用MobX的action.bound批量处理表单状态更新，输入数量后，仅触发 “金额计算” 相关状态更新，避免表单整体重渲染，交互响应时间从 150ms 降至 70ms。
6. CLS：优化布局偏移，确保页面元素位置稳定。
    + 订单薄：固定价格、数量、合集列的宽度，避免订单信息更新时导致的布局偏移
    + k线图：固定宽度、高度，避免数据更新时导致的布局偏移