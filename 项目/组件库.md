## 项目背景：
为提高前端组件开发和复用效率，决定搭建一套支持多包管理的组件库，实现组件的高效复用和文档化展示，提升团队整体开发效率。

## 技术栈：
taro、rollup、lerna、webpack、react-markdown

## 主要职责与实现：
+ 技术选型及独立负责功能开发，组内培训，组织前端人员沉淀组件
+ 采用 lerna 进行多包管理，将项目划分为组件核心库、demo、文档三个包
+ 在组件核心库开发中，组件不直接引用样式，使用 rollup-plugin-copy 插件，打包后将样式文件复制到构建产物，实现样式按需加载
+ demo实现较为简单，基于tarojs/cli开发，通过yarn link和核心组件库建立软链接，yarn: dev即可查看组件demo
+ 文档：demo 项目要在 taro 环境下运行，所以很难实现像 dumi 那样代码即文档的效果，参考了taro-ui也没有实现这样的效果，也看了dumi，官方表示目前没有支持 taro 的计划，所以基于umijs框架搭建，使用react-markdown渲染文档内容，demo组件的预览则是通过将demo 项目编译成 h5，然后通过 iframe 引用

## 工作成果：
+ 组织团队成员沉淀组件30+，制定开发规范和流程，提升了组件的质量和可维护性
+ 组件复用率提升60%以上，团队开发效率提升30%+，降低了公司的开发成本 

## Monorepo架构
+ 是什么
    - 将多个相关的项目（如组件库、demo、文档等）存储在一个代码仓库中，通过统一的构建工具（如lerna）进行管理和发布
+ 优势
    - 集中管理：多个项目存储在一个代码仓库中，方便管理和维护
    - 共享代码和依赖：不同模块之间可以轻松共享代码和工具
    - 版本统一：自动化的版本控制
      - 固定版本模式：所有包使用同一版本号
      - 独立版本模式：每个包使用独立的版本号
    - 通过工作区（Workspace）机制，内部包之间可直接引用源码（无需发布到 npm），且版本自动同步
    - 简化发布流程：使用 lerna 进行发布时，只需要在根目录执行一次发布命令，即可同时发布所有子包，避免了手动发布每个包的繁琐过程

## workspaces
+ 在根目录的 package.json 中声明子项目路径，包管理工具会自动识别这些子项目，并将它们视为 “工作区” 的一部分。
例如：
```json
{
  "name": "my-monorepo",
  "workspaces": {
    "packages": [
      "packages/*"
    ]
  },
}
```
+ 工作区内的子项目会自动创建软链接，无需将包发布到 npm，方便在开发过程中进行调试和测试。
+ 多个子项目的公共依赖会被安装到根目录的 node_modules 中，避免了重复安装，节省了空间。

## lerna
+ 是什么
    - 一个用于管理多个 npm 包的工具，它可以帮助我们在 Monorepo 架构中更方便地进行版本管理、发布和依赖管理。
+ 优势
    - 依赖共享：将包之间共有的依赖提取出来放到根目录的node_modules下
    - 版本管理：lerna 可以帮助我们管理多个包的版本，确保它们之间的依赖关系是正确的。
    - 发布管理：lerna 可以帮助我们更方便地发布多个包，避免了手动发布每个包的繁琐过程。
+ 使用：
    - lerna:bootstrap: 安装所有子项目的依赖，创建软链接，确保子项目之间的依赖关系正确。
    - lerna:publish: 发布
    - 设置固定版本/独立版本：
      - 固定版本模式：在lerna.json中配置"version":"1.00"
      - 独立版本模式：在lerna.json中配置"version":"independent"

## 增加一个入口文件
将组件在index.ts 入口文件中引入
```typescript
// index.ts
export { Col, Row } from './components/grid';
```

## 支持Tree-shaking
Tree-shaking 是现代前端打包工具（如 Webpack、Rollup、Vite）用于消除未使用代码（“死代码”）的优化技术，核心目标是减小最终产物体积。其工作原理基于 ES 模块（ESM）的静态分析能力。
1. 依赖 ESM 的 “静态结构”
  + ESM 是 “静态” 的：导入 / 导出的内容在编译时（打包阶段）就能确定，无需执行代码
  + CommonJS 是 “动态” 的：导入的内容只能在运行时确定，打包工具无法提前分析哪些代码被使用
  + 因此，Tree-shaking 只对 ESM 有效，对 CommonJS 代码无效
2. 标记 “未使用的导出”
  + 打包工具（如 Rollup）会遍历整个模块依赖树，分析每个模块的导出（export）和其他模块对这些导出的引用（import），标记出 “未被任何地方引用的导出”
3. 判断副作用
  + 标记出未使用的导出后，打包工具会尝试删除这些代码，但需要满足一个前提：被删除的代码没有 “副作用”（指代码执行时会对外部环境产生影响（如修改全局变量、执行 DOM 操作、注册事件等））
  + sideEffects 配置：为了告诉打包工具 “哪些文件有副作用，不能随意删除”，需要在 package.json 中通过 sideEffects 声明。设置 "sideEffects": false，则表示该包中所有文件均无副作用，未使用的代码可安全删除
4. 压缩阶段最终剔除
  + 在打包的最后阶段（通常是代码压缩时，如使用 Terser），工具会将标记为 “未使用且无副作用” 的代码从最终产物中彻底删除，完成 Tree-shaking
5. webpack4+ 生产环境默认启用Tree-shaking

## 按需加载实现原理
1. 组件库必须使用 ESM + modules 结构拆分每个组件，打包输出esm规范的代码
2. 通过babel插件（babel-plugin-import）转换引入路径，将入口路径转换到具体文件路径
```typescript
// 转换前
import { Button } from "my-ui";
// 转换后
import Button from "my-ui/es/button";
import "my-ui/es/button/style/index.css";
```
3. Tree-shaking：构建工具会在打包时分析哪些模块被使用，移除没被使用的模块，前提是：组件必须是 ES Module（ESM）导出的
```typescript
export const Button = ...
export const Input = ...
export default { Button, Input }
```