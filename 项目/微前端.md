## 样式隔离如何实现：shadow dom
+ shadow dom内部的样式不会被外部样式影响，也不会影响外部样式
```typescript
<!-- 宿主元素 -->
<div id="myHost"></div>

<script>
  // 1. 获取宿主元素
  const host = document.getElementById('myHost');

  // 2. 创建 Shadow Root（mode 控制封装级别）
  // mode: 'open' → 允许外部通过 host.shadowRoot 访问
  // mode: 'closed' → 完全封闭，外部无法访问（如浏览器原生组件）
  const shadowRoot = host.attachShadow({ mode: 'open' });

  // 3. 向 Shadow DOM 中添加内容（内部 DOM）
  shadowRoot.innerHTML = `
    <style>
      /* 内部样式：只影响 Shadow DOM 内部 */
      .title { color: red; font-size: 20px; }
    </style>
    <h2 class="title">我是 Shadow DOM 内部标题</h2>
    <p>这里的内容和样式不会被外部干扰</p>
    <!-- 插槽：接收外部传入的内容 -->
    <slot name="content"></slot>
  `;
</script>

<!-- 外部向插槽插入内容 -->
<div id="myHost">
  <p slot="content">我是外部传入的内容，通过插槽显示</p>
</div>

<!-- 外部样式：不影响 Shadow DOM 内部 -->
<style>
  .title { color: blue; } /* 对 Shadow DOM 内的 .title 无效 */
</style>
```

## js隔离如何实现
qiankun 主要通过 沙箱（Sandbox）机制 实现 JS 隔离，具体分为三种沙箱模式，适配不同场景
1. 快照沙箱（SnapshotSandbox）
  + 适用场景：不支持 Proxy 的低版本浏览器（如 IE11），或单个子应用独占页面的场景（无多子应用同时激活）。
  + 实现原理：
    - 激活时：记录当前全局环境（window）的快照（深拷贝 window 上的所有属性）。
    - 运行时：子应用直接修改全局 window。
    - 卸载时：恢复全局环境到激活前的快照，丢弃子应用的修改。
2. 代理沙箱（LegacyProxySandbox）
  + 适用场景：支持 Proxy 的现代浏览器，需多子应用同时激活（如主应用导航栏 + 子应用内容区共存）
  + 实现原理：
    - 为子应用创建一个 window 代理对象（Proxy），子应用的所有全局操作都通过代理执行
    - 子应用读取属性时：优先读自身修改的属性，若无则读主应用的 window
    - 子应用修改属性时：仅修改代理对象内的 “私有空间”，不影响真实 window
3. 严格模式代理沙箱（ProxySandbox）
  + 适用场景：现代浏览器，多子应用同时激活，且需更安全的隔离（qiankun 默认推荐）
  + 实现原理：
    - 不直接替换全局 window，而是通过 函数作用域 + Proxy 隔离子应用代码：
    - 子应用的所有代码在一个独立函数作用域内执行，该作用域的 this 和全局变量指向代理对象。代理对象对 window 的读写进行拦截，私有属性存在子应用的 privateWindow，公共属性共享主应用 window。
    - 对副作用（如 setTimeout、addEventListener）进行劫持跟踪：子应用执行 setTimeout 时，记录定时器 ID，卸载时自动清除。监听 window 事件时，记录事件监听函数，卸载时自动移除

## 如何避免主、子应用间引入公共组件，打包多次
### module federation
1. 跨应用共享模块（无需重复打包）：允许一个应用（称为 “远程应用”）将自身的模块（组件、工具函数等）暴露出去，其他应用（称为 “宿主应用”）可以像导入本地模块一样直接使用，且无需将共享模块打包到宿主应用中，减少冗余代码。
2. 动态加载远程模块（按需加载）：宿主应用可以在需要时（如用户点击按钮）才动态加载远程应用的模块，避免初始加载体积过大，提升首屏性能。
3. 共享依赖（避免重复加载）：若多个应用依赖同一个库（如 React、Lodash），Module Federation 可配置 “共享依赖”，确保该库在浏览器中只加载一次，避免重复占用内存和带宽。
4. 支持双向共享：应用 A 可以导入应用 B 的模块，应用 B 也可以同时导入应用 A 的模块
```
// 远程应用 webpack.config.js
const { ModuleFederationPlugin } = require('webpack').container;

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'remoteApp', // 远程应用的名称（全局唯一）
      filename: 'remoteEntry.js', // 远程入口文件（供宿主应用加载）
      exposes: {
        './Button': './src/components/Button', // 暴露的模块路径（键为别名，值为本地路径）
        './utils': './src/utils' // 暴露工具函数
      },
      shared: ['react', 'react-dom'] // 声明共享的依赖
    })
  ]
};

// 宿主应用 webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'hostApp',
      remotes: {
        // 远程应用别名: "远程应用名称@远程入口文件URL"
        remoteApp: 'remoteApp@http://localhost:3001/remoteEntry.js'
      },
      shared: ['react', 'react-dom'] // 与远程应用共享依赖
    })
  ]
};

// 像导入本地模块一样使用
import { Button } from 'remoteApp/Button';
import { formatDate } from 'remoteApp/utils';

function App() {
  return <Button onClick={() => console.log(formatDate(new Date()))}>远程按钮</Button>;
}
```