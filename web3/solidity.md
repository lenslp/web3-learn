## Solidity 是什么？
Solidity 是一种静态类型的、编译型的智能合约语言，用于在以太坊平台上编写智能合约。
## 基本数据类型有哪些
1. 布尔型（bool）
2. 整型（int、uint）：
   - int：有符号整型，范围为 -2^255 到 2^255 - 1
   - uint：无符号整型，范围为 0 到 2^256 - 1
3. 地址型（address）
4. 字节型（byte）
5. 字符串型（string）
6. 数组型（array）
7. 结构体型（struct）
8. 枚举型（enum）
9. 映射型（mapping）
    - 映射是一种键值对的存储结构，用于存储和检索数据。
    - 映射的键必须是一种可以进行哈希计算的类型，如地址、整型或字节型。
    - 映射的值可以是任意类型，包括其他映射、结构体、数组等。
### msg.sender
- `msg.sender` 是一个全局变量，用于获取当前调用合约的地址。指向调用者
- 当合约被外部账户调用时，`msg.sender` 就是调用合约的账户地址。
- 当合约A被合约B调用时，`msg.sender` 就是合约B的地址。
- 当合约被交易调用时，`msg.sender` 就是发送交易的账户地址。
### msg.value
- `msg.value` 是一个全局变量，用于获取当前调用合约的交易金额（以太币）。
- 当合约被外部账户调用时，`msg.value` 就是调用合约的交易金额。
- 当合约被交易调用时，`msg.value` 就是发送交易的交易金额。
## 变量修饰符：storage、memory、calldata 的区别？
- storage：存储在合约的状态变量中，永久存在于合约的存储中。可读写。gas成本高
- memory：存储在函数调用期间的临时内存中，函数调用结束后会被清除。可读写。gas成本中等
- calldata：存储在函数调用期间的临时内存中，函数调用结束后会被清除。只读。gas成本低
## 函数的可见性修饰符有哪些？
- public：公开的，任何合约或账户都可以调用。
- private：私有的，只能在合约内部调用。
- internal：内部的，只能在合约内部和继承合约中调用。
- external：外部的，不能在合约内部调用，只能通过合约的接口或外部调用。比如用户可以通过钱包调用合约的函数。
## 函数的view、pure、payable 有什么区别？
- view：视图函数，不修改合约的状态，只能读取状态变量。
- pure：纯函数，不修改合约的状态，也不读取状态变量。
- payable：可支付函数，允许函数接收以太币作为支付。
## immutable 关键字
- 用于定义不可变的状态变量，变量只能在 构造函数中 设置一次，一旦赋值，就不能再修改。
- 不可变的状态变量在合约部署时就必须赋值，后续不能再修改。
- 不可变的状态变量可以在合约内部使用，也可以在合约外部使用。
## 函数自定义修饰符如何定义和使用？
- 自定义修饰符使用 `modifier` 关键字定义，后面跟着修饰符的名称和参数列表。
- 修饰符可以在函数定义之前使用，用于添加额外的检查或逻辑。
```
modifier onlyOwner {
    require(msg.sender == owner, "Only owner can call this function");
    _;
}
```
## solidity的继承机制
- 通过 is 实现继承，例：contract A is B {}
- 可以继承一个合约，也可以继承多个合约
- 继承的合约可以重写父合约的函数，使用 `override` 关键字 。
- 可以使用 `super` 关键字调用父合约的函数。
## 接口和抽象合约的区别？
- 接口：接口是一种合约规范，定义了合约的函数和事件，但不包含实现代码。合约可以实现接口，从而符合接口的规范。
- 抽象合约：抽象合约是一种合约模板，包含了函数和事件的声明，但没有具体的实现代码。合约可以继承抽象合约，从而实现其中的函数和事件。
- 接口和抽象合约的区别：
  - 接口只能定义函数和事件的规范，不能包含实现代码。
  - 抽象合约可以定义函数和事件的规范，也可以包含实现代码。
  - 合约可以实现接口，从而符合接口的规范。
  - 合约可以继承抽象合约，从而实现其中的函数和事件。
## 事件（Event）
### 定义
- 通过 `event` 关键字定义事件，后面跟着事件的名称和参数列表。
- 事件可以在合约内部的函数中触发，使用 `emit` 关键字触发事件，后面跟着事件的名称和参数值。
```
event Transfer(address indexed from, address indexed to, uint256 value);

emit Transfer(msg.sender, to, value);
```
### 核心作用
- 永久记录关键操作：当合约中触发事件（如转账、授权、状态变更）时，事件数据会被打包进区块的日志中，成为区块链不可篡改的一部分。例如 ERC20 代币的 Transfer 事件会记录转账方、接收方和金额，永久留存转账记录。
- 前端应用可以通过监听这些事件来实时更新UI状态
- 事件提供了清晰的操作审计线索，有助于调试合约问题和验证合约行为是否符合预期
- 不占用合约存储：事件数据不会占用合约的存储空间，而是被打包进区块的日志中。
### 低级调用
- 低级调用是 Solidity 中直接与以太坊虚拟机（EVM）交互的调用方式。
- Solidity 提供了三种主要的低级调用方法：call、delegatecall、staticcall。
- 灵活性比较高，要注意防护
### transfer、send、call的区别
- transfer：自动回滚，但 Gas 限制固定，已被弃用
- send：返回布尔值，需手动检查，Gas 限制固定，已被弃用
- call：最灵活，可自定义 Gas，需要手动防护重入攻击， 推荐使用
现代 Solidity 开发建议 ：
- 使用 call 方法进行以太币转账
- 结合 ReentrancyGuard 防止重入攻击
- 先更新状态，后执行外部调用
- 添加适当的错误处理和事件日志
