# Web3

## 聊一下你知道的钱包签名流程 
钱包签名的核心流程是：  
1. 前端生成待签名数据message：  
    + 可以是简单的字符串消息，也可以是结构化数据（EIP-712）  
    + 消息中通常包含防重放的 nonce(后端返回) 和时间戳等信息，确保每次签名唯一且有时效性
2. 通过钱包（如 MetaMask）请求用户授权，钱包使用私钥对数据进行 （私钥不出本地）  
    + 调用viem的signMessage（personal_sign）触发钱包签名弹框
    + 钱包返回签名结果（signature）给前端
3. 前端将message + signature + address发送给后端
4. 后端通过调用viem的verifyMessage解析签名，如果返回的结果地址和前端传过来的address一致，则验签成功，证明消息确实是该地址持有者签名的。
```typescript
// 前端调用钱包签名
import { useSignMessage } from 'wagmi';
const { signMessageAsync } = useSignMessage();
const message = `Login to Web3 University\nAddress: ${address}\nNonce: ${nonce}\nTimestamp: ${Date.now()}`;
// 使用钱包签名（底层 viem -> personal_sign）
const signature = await signMessageAsync({ address, message });
// 把地址、消息和签名发给后端验签
const verifyRes = await fetch('http://localhost:3000/verify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ address, message, signature }),
})

// 后端验签
import { verifyMessage, recoverMessageAddress } from 'viem';
const recovered = verifyMessage({ address, message, signature });
if(recovered){
    // 验签成功
} else {
    // 验签失败
}

// 或者通过recoverMessageAddress拿到地址自行对比
const recoveredAddress = recoverMessageAddress({ message, signature });
if(recoveredAddress === address){
    // 验签成功
} else {
    // 验签失败
}
```

## 钱包助记词怎么管理的，助记词怎么派生出多链地址的  
1. 作用  
    + 助记词是生成和恢复钱包私钥的关键  
    + 用户通过助记词可以在不同设备上恢复钱包访问权限
    + 通常由 12/24 个单词组成，符合 BIP39 标准
2. 管理   
    + 钱包生成助记词后，离线保存、用户备份  
    + 助记词用于生成主私钥（master private key），从而派生出多个子私钥和地址  
3. 派生多链地址  
    + 助记词通过 BIP39(规范) 生成种子，再通过 BIP32/BIP44（规范） 派生出不同路径的私钥，不同链使用不同的 coin type，因此同一个助记词可以生成多条链、多个账户、无限个地址
4. 同一个钱包下的多个账号，默认是共用同一套助记词的，只是各自用这套助记词派生出的不同私钥/地址。

## 浏览器钱包助记词的安全性 / 存储 / 加密解密，顺带对比 privy 的 TEE  
1. 存储位置：
    + 助记词、各账户私钥、密码等，都会被打包成一个“加密金库”，保存在浏览器扩展程序存储->本地存储里。
2. 加密 / 解密过程：
    + 加密：用户设置一个密码，钱包使用该密码通过 KDF（如 PBKDF2、scrypt）生成加密密钥，然后用该密钥对助记词和私钥进行对称加密（如 AES），加密后的数据存储在本地。
    + 解密：用户登录时输入密码，钱包通过相同的 KDF 生成解密密钥，解密助记词和私钥，放到内存中供使用，锁定或关闭时会清掉内存里的明文。
3. 安全性：
    + 优点：助记词默认只存在本地加密文件里，不会自动备份到云端；攻击者需要同时拿到你设备上的加密数据和密码才有机会解密。
    + 缺点：如果设备被恶意软件入侵，黑客可以拿到你加密后的私钥和助记词，在有足够时间和算力的前提下，可以尝试爆破你的钱包密码；密码越弱、设备越不安全，风险就越高。一旦密码被破解，助记词和私钥就会暴露，资金面临被盗风险。
4. Privy 的 TEE 方案：
    + 私钥不在浏览器本地保存，也不会以明文或可解密形式出现在应用服务器上，私钥在服务器侧的 TEE 中生成和管理，被拆分为多份 key share，只有在 TEE 内部且通过权限校验时才短暂重构用于签名，应用和用户设备从来拿不到完整私钥。

## nonce 值是干啥的  
1. 交易签名中的nonce:
    + 标记交易顺序，比如：账户的第一笔交易 nonce 是 0，第二笔是 1，依此类推，这样矿工就知道这些交易应该按什么顺序打包。
    + 防止重放攻击：相同的交易数据如果被重复发送，由于 nonce 不同，矿工会识别为不同的交易，从而避免重复执行。
    + 支持替换未确认交易：用户可以通过发送相同 nonce 的新交易来替换之前未确认的交易，通常用于加快交易确认速度或修改交易参数。
2. 登录签名/业务防重放签名中的nonce:
    + 防止同一个签名被重复使用。
    + nonce可以用随机数，确保每条消息的唯一性。

## 发送交易的时候怎么预估 gas  
**答：**  
- 使用 `eth_estimateGas`  
- 结合当前 `baseFee + priorityFee`  
- 通常预留 1.2~1.5 倍 buffer  

## 接触过 sol, btc 网络吗  
**答：**  
- BTC：UTXO 模型、无智能合约  
- Solana：Account 模型，高 TPS，并行执行  

---

## 大概介绍下 BTC UTXO 模型  
**答：**  
- 每笔交易消耗旧 UTXO  
- 生成新的 UTXO  
- 没有账户余额概念  
- 易并行、可追溯  

---

## 有没有做过 swap，会做吗  
**答：**  
- 基于 AMM（Uniswap V2 / V3）  
- 计算最优路径  
- 考虑滑点、流动性、手续费  

---

## 后端的 token 验证有接触过吗，是怎么做的  
**答：**  
- 常见使用 JWT  
- 校验签名、过期时间、issuer  
- 可结合链上签名作为登录凭证  

---

## 一般项目在用户登录后，token 是怎么发的，顺带介绍下我们项目 token 是怎么由 privy 管理的，前后端怎么用  
**答：**  
- 用户签名登录  
- 后端验证签名后生成 JWT  
- Privy 托管私钥并在 TEE 中完成签名  
- 前端只持有访问 token  

---

# React

## 16、17、18 分别做了什么重要更新  
**答：**  
- 16：Fiber 架构、Error Boundary  
- 17：过渡版本，兼容性改进  
- 18：并发渲染、自动批处理、Suspense 增强  

---

## 16.8 之后新增了哪些重要的 API  
**答：**  
- Hooks：useState、useEffect、useContext  
- useMemo、useCallback、useRef  

---

## 16.8 之后 fiber 架构有什么变化  
**答：**  
- 可中断渲染  
- 任务分片  
- 优先级调度  

---

## fiber 的优化最重要是调用了浏览器哪个 API  
**答：**  
- `requestIdleCallback`  
- `MessageChannel`  

---

## 16.8 之后中断渲染的原理  
**答：**  
- 将渲染任务拆分成小单元  
- 高优先级任务可打断低优先级  

---

## hooks 不能放在条件判断中的原因  
**答：**  
- hooks 依赖调用顺序  
- 条件语句会破坏 hook 链表  

---

## 看你简历上的项目用了 jotai，说一下 jotai 和其他状态管理不一样的地方  
**答：**  
- 原子化状态管理  
- 无全局 store  
- 按需订阅，性能好  

---

## 性能优化一般你是怎么做的  
**答：**  
- memo / useMemo / useCallback  
- 虚拟列表  
- 代码分割  
- 减少不必要渲染  

---

## webpack 分包写过吗，你是怎么分的  
**答：**  
- vendor 拆分  
- 动态 import  
- 公共依赖抽离  

---

# JS 基础

## 箭头函数和普通函数有哪些重要的区别  
**答：**  
- 没有自己的 this  
- 没有 arguments  
- 不能作为构造函数  

---

## 介绍下事件循环机制  
**答：**  
- 同步任务先执行  
- 再执行微任务（Promise）  
- 最后执行宏任务（setTimeout、I/O）  

---

# 浏览器

## 说一下浏览器的运行架构  
**答：**  
- 多进程架构  
- Browser / Renderer / GPU / Network  

---

## 说一下渲染的流程  
**答：**  
1. 解析 HTML → DOM  
2. 解析 CSS → CSSOM  
3. 合成 Render Tree  
4. Layout  
5. Paint  
6. Composite  
