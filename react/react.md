## React设计理念
1. 声明式编程：开发者只需要描述UI在不同状态下应该是什么样子，react会根据描述自动更新UI
2. 组件化：将UI拆分成独立、可复用的组件，每个组件管理自己的状态和渲染，组件之间可以组合、嵌套，形成复杂的UI
3. 单向数据流：数据只能从父组件流向子组件，避免了复杂的状态管理和数据同步问题
4. 虚拟DOM
5. 函数式编程：react使用函数式编程的方式来描述UI，组件是纯函数，接收props作为输入，返回一个描述UI的虚拟dom树。

## JSX的本质
1. 描述 UI 的 JavaScript 对象
2. JSX 最终会被 Babel 等工具转换为 React.createElement 调用，生成 React 元素（虚拟 DOM 节点）
3. 示例：
  + JSX 代码：
    ```jsx
    <div>
      <h1>Hello, React!</h1>
    </div>
    ```
  + 转换后的 JavaScript 代码：
    ```javascript
    React.createElement(
      'div',
      null,
      React.createElement('h1', null, 'Hello, React!')
    );
    ```
4. react17 及以后版本中，JSX 不再需要引入 React 库，因为 React.createElement 已经被内建到 React 中
5. 优点：
  + 简洁：JSX 语法更接近 HTML，更易于阅读和编写
  + 类型安全：JSX 会在编译时检查类型错误，避免运行时错误
  + 可组合：JSX 可以像函数一样组合，形成复杂的 UI 结构

## 分离打包
1. 分离打包：
  + 客户端代码：包含 React 组件、事件处理器、状态管理等，打包成一个 js 文件，加载到浏览器中执行
  + 服务器端代码：包含 React 组件的渲染逻辑、数据获取等，打包成一个 js 文件，在服务器端执行
  + 服务端和客户端可能存在共享代码，共享代码会被分别打包到服务端和客户端文件中，根据运行环境执行对应逻辑
2. 原因：
  + 服务端组件的代码不会被打包到客户端文件中，减少客户端js体积

## 水合（hydration）
1. 是什么：水合（Hydration） 是指将服务器渲染的静态 HTML 转换为可交互的 React 组件的过程。它是连接 “服务器端渲染（SSR）” 或 “静态站点生成（SSG）” 与客户端交互的关键步骤，确保用户既能快速看到内容，又能正常与页面交互。 
  + 水合过程：
    + 服务器生成静态html：服务器执行 React 组件，生成静态 HTML，返回给客户端
    + 客户端接收服务端返回的html和初始状态，立即渲染静态html并异步加载js资源
    + 客户端执行 React 代码，启动水合：js加载完之后，客户端会重新执行组件代码，生成虚拟dom；并且对比服务器生成的静态html结构和客户端生成的虚拟dom结构，必须完全匹配
    + 将事件处理器绑定到dom元素上，并初始化状态
  + 实现原理：
    + 读取服务端返回的真实 DOM 根节点；
    + 客户端执行组件逻辑生成虚拟 DOM（VNode）；
    + 递归对比真实 DOM 与虚拟 DOM 的结构（标签、属性、文本等）；
    + 匹配成功后，在真实 DOM 上绑定事件处理器，初始化组件状态；
    + 若匹配失败，放弃复用，直接用虚拟 DOM 重新渲染
2. 为什么需要水合
+ 服务器端渲染（SSR）：用户请求数据时，服务端将渲染好的html返回给客户端，这个html是静态的，没有绑定事件和状态，客户端需要将这些静态HTML转换为可交互的React组件，这就是水合的过程。
+ 静态站点生成（SSG）：构建时生成静态html，并预存到服务器，用户请求时直接返回预存的html，客户端需要将这些静态HTML转换为可交互的React组件，这也是水合的过程。
3. 水合的过程
+ 服务器生成静态html：服务器执行 React 组件，生成静态 HTML，返回给客户端
+ 客户端初渲染与资源加载：客户端收到html立即渲染到页面上，并加载js
+ 客户端执行 React 代码，启动水合：js加载完之后，客户端会重新执行组件代码，生成虚拟dom；并且对比服务器生成的静态html结构和客户端生成的虚拟dom结构，必须完全匹配
+ 将事件处理器绑定到dom元素上，并初始化状态

## 什么是虚拟dom
### 是什么
用JavaScript对象来描述真实的dom结构
```
const virtualDOM = {
  type: 'div',
  props: {
    className: 'container',
    children: [
      {
        type: 'h1',
        props: {
          children: 'Hello World'
        }
      }
    ]
  }
}
```
### 产生背景
频繁操作dom会导致页面的重排、重绘，阻塞UI线程渲染，导致页面卡顿
### 工作机制
+ 当组件状态发生变化时，react会启动协调过程（reconcilitation）
+ 根据最新状态在内存中构建一棵新的虚拟dom树
+ 将新的虚拟dom树和旧的虚拟dom树进行逐层比较（diff算法）
+ 通过diff算法找出两棵树的最小差异
+ 将所有差异打包，一次性的更新到真实dom
### 解决了什么问题
+ 提高应用性能：避免不必要的dom操作，只更新变化的部分；批量更新，减少重排和重绘
+ 将开发者从繁琐的dom操作中解放出来
+ 跨平台，虚拟dom相当于一个抽象层，可以交给不同的平台去渲染执行，比如web端和react native 
### 一定比操作真实dom快吗
不一定，简单的场景直接操作真实dom更快，虚拟dom需要先在内存中构建，然后再进行比较和更新，所以在简单的场景下，直接操作真实dom更快

## diff算法
### 是什么
diff算法是react中用于比较虚拟dom树的变化的算法，它的核心思想是将新的虚拟dom树与旧的虚拟dom树进行比较，找出差异，然后根据差异来更新真实dom
### 比较策略
+ 同级比较：只对同层级节点进行比较，不会跨层级比较，降低算法复杂度。
  + 如果同级节点类型不同，则直接销毁旧的节点及其子节点，创建新的节点和子节点
  + 如果同级节点类型相同，要分两种情况
    + 如果是元素节点，比较节点的属性（className、style等）是否变化；如果没有变化，则继续递归比较子节点
    + 如果是组件节点，比较组件的props是否变化；如果没有变化，则继续递归比较子组件
+ 同级子节点比较：对于同一层级的子节点，使用key来标识节点的唯一性
  + 有key的话，react可以判断节点是否发生了移动、新增、删除，如果移动了则会将节点从旧的位置移动到新的位置
  + 没有key的话，react只能通过节点类型来判断，如果节点只是移动了顺序，react会错误的认为节点发生了删除和新增，导致性能问题

##  React中key的作用
+ 唯一标识：key是用来标识节点唯一性的，react根据key来判断节点是否发生了移动、新增、删除，优化渲染性能，避免状态错误
+ 如果key相同，类型相同，react会认为节点未被替换，只用更新其内容或属性
+ 如果key相同，类型不同，会删除旧的节点，创建新的节点
+ 如果key不同，react会认为节点被替换了，会删除旧的节点，创建新的节点
+ 没有key时，react默认使用index作为key，但是对于动态列表会导致问题
  + 若列表项包含输入框等带状态的组件，索引变化会使 React 错误关联新旧元素的状态。例如，删除前序元素后，后续元素的key（索引）会前移，导致输入内容与显示内容不匹配。
  + 当列表进行删除、插入、排序时，索引会随元素位置变化而改变。React 会误判元素为 “新创建” 而非 “移动”，导致不必要的 DOM 销毁与重建，增加性能开销

## fiber机制
### 产生背景
+ react16之前，通过递归的方式遍历组件树，一旦开启递归，就无法中断，直到遍历完成。
如果嵌套层级过深的话，则会导致页面卡顿，影响用户交互体验。
+ react16引入fiber机制，将这个 “不可中断的长任务” 拆分成可中断、可恢复的小任务单元，通过优先级调度，在浏览器空闲的时候执行，保证主线程流畅。
### fiber核心设计
1. 数据结构
  + fiber节点：每个组件都对应一个fiber节点，节点中包含了：
    // 组件信息
    + 组件的类型（函数组件、类组件、原生组件等）
    + 关联的真实dom节点
    + 组件的状态（state）
    + 组件的属性（props）
    // hooks相关
    + 组件的hooks状态（state）
    + 组件的hooks队列（queue）
    // 链表指针
    + 指向父节点的指针（return）
    + 指向子节点的指针（child）
    + 指向兄弟节点的指针（sibling）
    // 副作用与优先级
    + 副作用链表：标记当前节点的副作用，如更新、插入、删除等
    + 任务优先级（priority）
    // 双缓存相关
    + 指向当前正在渲染的树的指针（alternate）
  + 通过链表结构组织fiber节点，使得 React 可以随时中断遍历，并从任意节点恢复（通过指针找到下一个任务单元），而无需重新遍历整个树。
2. 双缓存机制：react使用双缓存机制来存储虚拟dom树，一个是当前正在渲染的树，一个是新的构建中的树，构建完成后交换指针，新的树成为当前正在渲染的树。避免了 DOM 半更新闪烁
3. 渲染机制
  + 调度阶段
    - 接收更新任务，放入调度队列，由调度器根据任务优先级来决定执行顺序
    - 利用浏览器的 requestIdleCallback 或 setTimeout 等 API，在主线程空闲时执行低优先级任务，在有高优先级任务时暂停当前任务。
    - 优先级排序：用户操作（如点击、输入）优先级最高
  + 协调阶段
    - 遍历fiber树（循环，非递归），通过diff算法对比新旧fiber节点，标记需要更新的节点（如新增、删除、属性变化），生成 “副作用链表”（effectList）
    - 可中断：此阶段的计算可以被高优先级的任务打断
    - 可恢复：基于链表结构，任务暂停后，已完成的工作不会丢失，恢复时从上次中断的fiber节点继续
    - 优先级：react为不同任务设置不同的优先级，高优先级任务会优先被执行（比如用户输入）
  + 提交阶段：
    - 根据协调阶段生成的 effectList，批量执行dom操作（如插入、更新、删除）。并调用组件生命周期钩子（如 componentDidMount、useEffect）
    - 此阶段不可中断，必须完成所有更新操作后才能继续执行后续任务
### 解决了什么问题
  + 避免页面卡顿：将长任务拆分为小单元，通过中断 / 恢复机制，确保主线程有时间处理用户交互、动画等关键操作
  + 更好的错误边界：渲染过程中若发生错误，可在提交阶段前捕获，避免整个应用崩溃。

## fiber简介版
React 的 Fiber 是 React 16 重构的核心协调机制，主要解决同步渲染的性能问题，可从三个核心点理解：
1. 工作单元重构：将长任务拆分为细粒度的 "工作单元"（每个单元对应一个组件），用链表结构替代递归栈，使任务可中断和恢复。
2. 优先级调度：引入任务优先级机制（如用户输入 > 动画 > 普通更新），高优先级任务可抢占执行，避免主线程长时间阻塞。
3. 双阶段处理：
协调阶段（可中断）：计算新旧虚拟 DOM 差异，标记需要更新的部分；
提交阶段（不可中断）：将差异同步到真实 DOM，执行副作用。

## 为什么fiber可中断、可恢复
1. 链表的每个节点都包含指向其他节点的指针，只需记住当前正在执行的节点，即可通过指针知道下一步该执行哪个节点。
2. 当任务被中断时，当前节点的状态会被保存下来（workInProgress fiber树），包括节点的状态（是否完成）、hooks的状态、指针等。
3. 当任务恢复时，从上次中断的节点继续执行，无需重新遍历整个树。

## 为什么react中props不可变？
### 维护单向数据流
+ 父组件可以通过props将数据传递给子组件，子组件只能通过props接收数据，不能直接修改props
+ 子组件如果需要修改数据，只能通过回调函数的方式通知父组件，由父组件来更新数据
+ 避免了复杂的状态管理和数据同步问题
+ 确保数据的单向流动，数据可追溯，便于调试和维护
### 保证组件状态渲染的可预测性
React 组件的渲染逻辑遵循 “纯函数原则”，相同的输入必然产生相同的输出。
### 保证react高效的更新机制
+ 由于 props 不可变，父组件传递给子组件的 props 若 “引用未变”，则代表 props 的内容一定未变（因为无法修改原有 props 对象，只能创建新对象）；若 “引用变化”，则代表 props 内容可能变化
+ 基于这一特性，React 可以通过 “浅比较” 快速判断 props 是否变化：只需对比 props 对象的引用，就能高效决定是否跳过子组件的重新渲染

## redux核心思想：store、action、reducer
### 单一数据源
  + 整个应用的状态都存储在一个单一的store中
### 状态是只读的
  + 不能直接修改store中的状态，状态的更新只能通过dispatch action来触发，action是一个普通的javascript对象，描述了状态的变化
### 状态变更由纯函数处理
  + reducer函数接收旧的state和action，根据action的类型和描述，返回新的state

## 其他的状态管理方案
  + zustand：可以看作轻量版redux
    + 和redux比较相似，都是单一数据源、自上而下的状态管理
    + 保留了redux的核心思想，去除了繁琐的模版
    + 通过create函数创建store，通过useStore hook来访问状态和dispatch action
  + jotai：一个基于原子状态的状态管理库，支持响应式编程，支持类组件和函数组件
    + 原子状态：将状态拆分为多个独立的原子状态，每个原子状态都有自己的状态值和更新函数
    + 响应式编程：当原子状态发生变化时，会自动触发依赖它的组件重新渲染
```
// 1. 创建 store
import { create } from 'zustand';
const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
  decrement: () => set(state => ({ count: state.count - 1 }))
}));

// 2. 组件中使用
const Counter = () => {
  const { count, increment } = useCounterStore();
  return (
    <div>
      {count}
      <button onClick={increment}>+</button>
    </div>
  );
};
```
  + mobx：一个基于可观察对象的状态管理库，支持响应式编程，支持类组件和函数组件
    + 通过@observable装饰器将状态标记为可观察对象
    + 通过@action标记修改状态的方法，也可以直接修改状态
    + 通过@observer装饰器将组件标记为可观察组件，当状态变化时，会自动触发组件的重新渲染
    + 通过@computed装饰器将计算属性标记为可观察属性，当依赖的状态变化时，会自动触发计算属性的重新计算
    + 也可以通过makeAutoObservable来自动将状态和方法标记为可观察对象和可操作方法
    + autorun：可以自动响应状态的变化，当状态变化时，会自动触发回调函数
    + reaction：监听特定状态变化，返回新值时执行函数
    + 响应式基于Es6的proxy和reflect实现

## 合成事件
+ 合成事件：React 为了优化事件处理性能，将浏览器原生事件封装成了合成事件（SyntheticEvent），所有事件都在事件冒泡阶段触发，避免了事件捕获阶段的性能问题
+ 合成事件的优势：
  + 跨浏览器兼容：不同浏览器对原生事件的实现存在差异（例如 IE 曾使用 attachEvent 而非标准的 addEventListener，事件对象属性也有差异）。合成事件将这些差异屏蔽，提供统一的 API（如 onClick、event.preventDefault()），开发者无需手动处理兼容性
  + 事件委托：React 不会将事件处理器直接绑定到 DOM 元素上，而是委托到组件树的根节点（通常是 document），减少 DOM 事件绑定的数量，提升性能
  + 事件池机制：合成事件对象在事件处理完成后会被回收并复用（清空属性后放入事件池），以减少频繁创建和销毁对象的内存开销。
+ 如何访问原生事件对象
  + 可以通过事件对象的nativeEvent属性来访问原生事件对象
  + 例如：e.nativeEvent.preventDefault() 来阻止默认行为

## useState是同步还是异步的
### react18之前
  + 合成事件、生命周期中异步批量更新：useState的更新是异步的，在合成事件中、生命周期中调用setState不会立即更新状态，而是先放入队列中，会在事件处理完成后批量更新状态
  + react管控不到的地方：比如：setTimeout、promise等回调中是同步更新的
### react18之后
  + 引入了自动批量更新机制，所有场景默认都批量更新
  + 可以通过flushSync来强制同步更新状态
```
  // 强制同步更新（立即执行并渲染）
  flushSync(() => {
          setCount(c => c + 1); // 这里会触发一次渲染
  });
```
### 闭包陷阱
  + useState 的“闭包陷阱”指的是在事件处理、异步回调等场景中，函数闭包捕获了“当次渲染的旧状态快照”，导致后续执行时读到过期的 state/props，从而出现值不更新、丢失更新或逻辑异常
```
function Component() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(count + 1); // 状态更新为1
    
    // 异步操作：1秒后执行
    setTimeout(() => {
      console.log(count); // 这里输出的是0，而不是1
    }, 1000);
  };
  return <button onClick={handleClick}>点击</button>;
}
```
### 如何实时获取最新的值
  + 可以使用useEffect来监听状态的变化，当状态变化时，会触发回调函数，在回调函数中可以获取最新的状态值
  + 函数式更新：setState中可以传入更新函数，React 会主动将当前最新状态作为参数传递给更新函数
  + useRef

## suspense
  + 作用：当组件在渲染过程中遇到未就绪的异步依赖（如 pending 的 Promise），React 会暂停当前组件树的渲染，向上寻找最近的 Suspense 组件，显示其 fallback 内容；当异步依赖就绪后，React 会恢复渲染被暂停的组件，并替换 fallback 内容
  + 原理：
    - 基于react的并发机制：中断 - 恢复
    - 当组件需要等待异步操作完成时，会暂停渲染，显示一个 fallback 组件，待异步操作完成后恢复渲染。
    - 被包裹的组件抛出一个promise，Suspense会捕获promise的状态
  + 核心价值：是将 “等待异步资源” 的逻辑与 “渲染内容” 的逻辑解耦，通过声明式的方式统一管理加载状态
  + 示例：
```
  // 1. 创建一个异步组件
  const MyAsyncComponent = React.lazy(() => import('./MyAsyncComponent'));

  // 2. 在父组件中使用 Suspense 包裹
  function MyParentComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <MyAsyncComponent />
        </Suspense>
      </div>
    );
  }
```

## 并发模式
1. 是一种可中断、可恢复的渲染机制，优先处理用户交互（如点击、输入）等更高优先级的任务，提升应用在复杂场景下的响应速度和用户体验。
```
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
```
2. 和fiber的关系
  + 并发模式基于fiber架构实现，利用fiber的可中断、可恢复特性，实现了任务的优先级调度和中断恢复
3. 新增了useTransition、useDeferredValue两个hook
  + useTransition：用于标记一个状态更新为低优先级，在高优先级任务完成后再执行。
  + useDeferredValue：用于延迟更新一个状态，在高优先级任务完成后再执行。

## React 组件渲染和更新的全过程
1. 初始化阶段：创建 Fiber 树和 Hooks 链表。
2. 调度阶段：根据任务优先级，将任务放入不同的队列中（如高优先级队列、低优先级队列）。
3. 协调阶段：通过diff算法，对比新旧 Fiber 树，找出需要更新的部分。
4. 提交阶段：将更新批量应用到真实 DOM。
5. 清理阶段：重置全局变量，清理上下文和hooks，准备下一次更新。
