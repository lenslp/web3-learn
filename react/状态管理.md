## immer
✅ 优点：
1. 简化不可变数据操作：通过“草稿”机制，允许直接修改状态，底层自动生成不可变副本。
2. 代码简洁易读：减少样板代码，提升开发效率。
3. 性能优化：仅在必要时创建新对象，避免不必要的深拷贝。
4. 与现有状态管理库兼容：可与 Redux、MobX 等结合使用。
❌ 缺点：
1. 学习曲线：需要理解“草稿”概念和工作原理。
2. 调试复杂性：自动生成的不可变副本可能增加调试难度。
3. 额外依赖：引入第三方库，增加项目体积。
💡 底层原理：
+ 基于原始状态创建一个 Proxy 代理对象（draft）
+ 用户对 draft 的“修改”会被记录
+ 在 produce 结束时，只对被修改的部分进行拷贝
+ 最终返回一个 新的不可变状态（immutable state）
💡 useImmer
```typescript
import { useImmer } from "use-immer";
function MyComponent() {
  const [state, updateState] = useImmer({ count: 0 });

  const increment = () => {
    updateState(draft => {
      draft.count += 1; // 直接修改 draft
    });
  };

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

## mobx
✅ 优点：
1. 自动响应式更新：只要数据变化，UI 自动更新（无需 setState / dispatch）。
2. 代码简洁：不需要写 reducer、action，只需定义 observable。
3. 性能优秀：按依赖关系自动更新，避免多余渲染。
4. 适合高频数据变化、实时性要求高的系统，例如：交易所、可视化监控面板、图表系统（如 TradingView）

❌ 缺点：
1. 响应式系统较“黑箱”：自动追踪依赖导致调试困难。
2. 逻辑分散：状态与更新逻辑分布在多个 store，不如 Redux 那样集中。

```typescript
// 类组件写法
1. makeAutoObservable(this) // 自动把类里的字段变成响应式的 observable，方法自动成为 action，派生属性变为 computed。
2. @observable // 将一个普通的类属性或对象属性变成可观察的状态
3. @action // 包装修改状态的函数
4. @computed // 定义自动缓存的派生值，它依赖一个或多个 @observable 状态，并且会在依赖变化时自动重新计算，同时带有缓存机制

// 函数式写法
1. useLocalObservable // 可以用于函数组件，只在组件生命周期内有效
2. observer() // 使 React 组件变成响应式组件，只要访问的 observable 值变化，组件就会重新渲染。
3. runInAction() // 用于在 action 中安全修改状态（类似批处理，避免不必要的多次触发）。
```

## Redux
✅ 优点：
1. 可预测性强：状态流清晰、纯函数更新。
2. 强大的调试与回溯能力（Redux DevTools）。
3. 中间件生态丰富：如 redux-thunk、redux-saga、redux-toolkit。
4. 大型团队协作友好：统一规范，易维护。

❌ 缺点：
1. 样板代码太多：reducer/action/type 模板重复。
2. 性能劣势：
    + dispatch 触发全局更新，Redux store 是单一全局状态树，dispatch时，整个 store 都会生成新对象引用，每次 dispatch 都会造成大量 diff / selector 运算。
    + Redux 要求 reducer 是 纯函数，禁止直接修改 state，每次更新都要浅拷贝对象，高频数据更新会导致频繁分配内存。
    + 可以通过Redux Toolkit（createSlice）拆分store，组件只订阅对应状态，减少重复渲染，但无法避免 “dispatch 全局通知” 带来的 diff 成本（dispatch时所用reducer还是都会执行）

## Zustand
✅ 优点：
1. 超轻量级（核心不到 2KB）。
2. 学习曲线极低：几分钟上手。
3. 函数式写法自然直观：不需要 action/reducer。
4. 自动优化性能：只更新订阅的组件。
5. 支持 async/await 异步逻辑，无需中间件。

❌ 缺点：
1. 生态相对较小（但增长快）。
2. 不支持响应式依赖追踪（不像 MobX 那样“自动”更新）。
3. 大型项目中组织结构需自己规范（没有官方架构约束）。

💡 使用场景：
1. 中小型项目、工具类应用、轻量前端项目、3D/可视化应用。例如：前端编辑器、配置面板、仪表控件、个人项目。

## jotai
✅ 优点：
1. 极简 API：核心概念只有 atom 和 useAtom，易学易用。
2. 灵活组合：可以轻松组合和衍生状态，支持异步数据。
3. 性能优异：只更新使用了特定 atom 的组件，避免不必要的渲染。
4. 原子化状态管理：每个 atom 独立管理自己的状态，便于拆分和复用。 
5. 与 React 紧密集成：利用 React 的 hooks 和 context 特性，使用体验自然流畅。
❌ 缺点：
1. 生态较小：相比 Redux 和 MobX，社区和插件较少。
2. 组织结构需自定义：大型项目中需要自行规范状态组织方式。
3. 学习曲线：虽然 API 简单，但理解原子化状态管理和依赖关系可能需要时间。
💡 使用场景：
1. 适合中小型项目、需要高度灵活状态管理的应用，如仪表盘、配置面板、个人项目等。
```typescript
import { atom, useAtom } from 'jotai';  
// 定义一个原子状态
const countAtom = atom(0);
// 在组件中使用原子状态
function Counter() {
  const [count, setCount] = useAtom(countAtom);
    return (
        <div>
            <span>{count}</span>
            <button onClick={() => setCount(c => c + 1)}>Increment</button>
        </div>
    );      
}
```
jotai-immer：结合 immer 使用，简化复杂状态更新