## mobx
✅ 优点：
1. 自动响应式更新：只要数据变化，UI 自动更新（无需 setState / dispatch）。
2. 代码简洁：不需要写 reducer、action，只需定义 observable。
3. 性能优秀：按依赖关系自动更新，避免多余渲染。
4. 适合高频数据变化、实时性要求高的系统，例如：交易所、可视化监控面板、图表系统（如 TradingView）

❌ 缺点：
1. 响应式系统较“黑箱”：自动追踪依赖导致调试困难。
2. 逻辑分散：状态与更新逻辑分布在多个 store，不如 Redux 那样集中。

```typescript
// 类组件写法
1. makeAutoObservable(this) // 自动把类里的字段变成响应式的 observable，方法自动成为 action，派生属性变为 computed。
2. @observable // 将一个普通的类属性或对象属性变成可观察的状态
3. @action // 包装修改状态的函数
4. @computed // 定义自动缓存的派生值，它依赖一个或多个 @observable 状态，并且会在依赖变化时自动重新计算，同时带有缓存机制

// 函数式写法
1. useLocalObservable // 可以用于函数组件，只在组件生命周期内有效
2. observer() // 使 React 组件变成响应式组件，只要访问的 observable 值变化，组件就会重新渲染。
3. runInAction() // 用于在 action 中安全修改状态（类似批处理，避免不必要的多次触发）。
```

## Redux
✅ 优点：
1. 可预测性强：状态流清晰、纯函数更新。
2. 强大的调试与回溯能力（Redux DevTools）。
3. 中间件生态丰富：如 redux-thunk、redux-saga、redux-toolkit。
4. 大型团队协作友好：统一规范，易维护。

❌ 缺点：
1. 样板代码太多：reducer/action/type 模板重复。
2. 性能劣势：
    + dispatch 触发全局更新，Redux store 是单一全局状态树，dispatch时，整个 store 都会生成新对象引用，每次 dispatch 都会造成大量 diff / selector 运算。
    + Redux 要求 reducer 是 纯函数，禁止直接修改 state，每次更新都要浅拷贝对象，高频数据更新会导致频繁分配内存。
    + 可以通过Redux Toolkit（createSlice）拆分store，组件只订阅对应状态，减少重复渲染，但无法避免 “dispatch 全局通知” 带来的 diff 成本（dispatch时所用reducer还是都会执行）

## Zustand
✅ 优点：
1. 超轻量级（核心不到 2KB）。
2. 学习曲线极低：几分钟上手。
3. 函数式写法自然直观：不需要 action/reducer。
4. 自动优化性能：只更新订阅的组件。
5. 支持 async/await 异步逻辑，无需中间件。

❌ 缺点：
1. 生态相对较小（但增长快）。
2. 不支持响应式依赖追踪（不像 MobX 那样“自动”更新）。
3. 大型项目中组织结构需自己规范（没有官方架构约束）。

💡 使用场景：
1. 中小型项目、工具类应用、轻量前端项目、3D/可视化应用。例如：前端编辑器、配置面板、仪表控件、个人项目。